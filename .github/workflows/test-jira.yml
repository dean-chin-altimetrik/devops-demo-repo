name: test-jira

on:
  workflow_dispatch:
    inputs:
      issue_key:
        description: "Release Scope Jira issue key"
        required: true
        type: string

permissions:
  contents: read

jobs:
  check-jira:
    runs-on: ubuntu-latest
    env:
      JIRA_BASE_URL: ${{ secrets.JIRA_BASE_URL }}
      JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
      JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
      ISSUE_KEY: ${{ inputs.issue_key }}

    steps:
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Fetch issue (type + description)
        id: fetch
        shell: bash
        run: |
          set -euo pipefail

          if [[ -z "${JIRA_BASE_URL}" || -z "${JIRA_EMAIL}" || -z "${JIRA_API_TOKEN}" ]]; then
            echo "One or more Jira secrets are missing." >&2
            exit 2
          fi

          # Ask for the specific fields we need and request rendered HTML for easier text extraction
          URL="${JIRA_BASE_URL}/rest/api/3/issue/${ISSUE_KEY}?fields=issuetype,description&expand=renderedFields"

          HTTP_STATUS=$(curl -sS -w "%{http_code}" -o /tmp/resp.json \
            -u "${JIRA_EMAIL}:${JIRA_API_TOKEN}" \
            -H "Accept: application/json" \
            "$URL")

          if [[ "$HTTP_STATUS" != "200" ]]; then
            echo "Failed to fetch issue ${ISSUE_KEY}. HTTP ${HTTP_STATUS}" >&2
            echo "Response:" >&2
            cat /tmp/resp.json >&2 || true
            exit 3
          fi

          ISSUE_TYPE=$(jq -r '.fields.issuetype.name // empty' /tmp/resp.json)
          # Prefer rendered HTML (easier to convert to plain text); fall back to raw ADF if needed
          DESC_HTML=$(jq -r '.renderedFields.description // empty' /tmp/resp.json)
          DESC_ADF=$(jq -c '.fields.description // empty' /tmp/resp.json)

          # If rendered HTML is empty, produce a rough text fallback from ADF
          if [[ -z "$DESC_HTML" || "$DESC_HTML" == "null" ]]; then
            # Very lightweight ADF -> text fallback (best-effort)
            DESC_TEXT=$(jq -r '
              def walkblocks($n):
                if type=="array" then map(walkblocks($n)) | join("\n")
                elif type=="object" and .type? then
                  if .type=="text" then .text // ""
                  elif .type=="paragraph" or .type=="heading" or .type=="bulletList" or .type=="orderedList"
                    then (.content // []) | map(walkblocks(.)) | join("\n")
                  elif .type=="listItem"
                    then (.content // []) | map(walkblocks(.)) | join("")
                  else (.content // []) | map(walkblocks(.)) | join("")
                  end
                else ""
                end;
              walkblocks(.)
            ' <<< "${DESC_ADF:-null}" | sed '/^[[:space:]]*$/d')
          else
            # Convert HTML to plain text and convert <table>â€¦</table> into Markdown tables (simple, best-effort)
            DESC_TEXT=$(printf "%s" "$DESC_HTML" \
              | python3 - <<'PY'
import sys, re, html
from html.parser import HTMLParser

html_in = sys.stdin.read()

class TableParser(HTMLParser):
    def __init__(self):
        super().__init__()
        self.tables = []
        self.in_table = False
        self.current_rows = []
        self.current_row = []
        self.in_cell = False
        self.cell_text = ''
        self.last_tag = None
        self.has_th = False

    def handle_starttag(self, tag, attrs):
        self.last_tag = tag
        if tag == 'table':
            self.in_table = True
            self.current_rows = []
            self.has_th = False
        elif tag == 'tr' and self.in_table:
            self.current_row = []
        elif tag in ('td','th') and self.in_table:
            self.in_cell = True
            self.cell_text = ''
            if tag == 'th':
                self.has_th = True

    def handle_endtag(self, tag):
        if tag in ('td','th') and self.in_table:
            self.in_cell = False
            self.current_row.append(self.cell_text.strip())
            self.cell_text = ''
        elif tag == 'tr' and self.in_table:
            self.current_rows.append(self.current_row)
            self.current_row = []
        elif tag == 'table' and self.in_table:
            self.tables.append({'rows': self.current_rows, 'has_th': self.has_th})
            self.in_table = False

    def handle_data(self, data):
        if self.in_cell:
            self.cell_text += data
parser = TableParser()
parser.feed(html_in)

out = html_in
# Replace tables from last to first to preserve indices
for tbl in reversed(parser.tables):
    rows = tbl['rows']
    if not rows:
        md = ''
    else:
        col_count = max(len(r) for r in rows)
        norm = [ [(r[i] if i < len(r) else '') for i in range(col_count)] for r in rows ]
        # compute widths
        widths = [max(len(html.unescape(cell)) for cell in col) for col in zip(*norm)]
        def mkrow(r):
            return '| ' + ' | '.join(html.unescape(cell).strip().ljust(widths[i]) for i,cell in enumerate(r)) + ' |'
        md_lines = []
        md_lines.append(mkrow(norm[0]))
        sep = '| ' + ' | '.join('-' * widths[i] for i in range(col_count)) + ' |'
        md_lines.append(sep)
        for r in norm[1:]:
            md_lines.append(mkrow(r))
        md = '\n'.join(md_lines)
    # replace first <table ...>...</table> occurrence
    out = re.sub(r'(?is)<table.*?</table>', lambda m: md, out, count=1)
# Basic tag to text conversion for remaining HTML
out = re.sub(r'(?i)<br\s*/?>', '\n', out)
out = re.sub(r'(?i)</p>', '\n\n', out)
out = re.sub(r'(?i)</li>', '\n', out)
out = re.sub(r'(?s)<[^>]+>', '', out)
print(out.strip())
PY
          fi

          IS_REL_SCOPE=false
          if [[ "$ISSUE_TYPE" == "REL-SCOPE" ]]; then
            IS_REL_SCOPE=true
          fi

          # Expose outputs
          {
            echo "issue_type=${ISSUE_TYPE}"
            echo "is_rel_scope=${IS_REL_SCOPE}"
            echo "description<<EOF"
            printf "%s\n" "$DESC_TEXT"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Log results
        run: |
          echo "Issue Type: ${{ steps.fetch.outputs.issue_type }}"
          echo "Is REL-SCOPE: ${{ steps.fetch.outputs.is_rel_scope }}"
          echo "----- Description -----"
          printf "%s\n" "${{ steps.fetch.outputs.description }}"

      # (Optional) Fail the job if the type is not REL-SCOPE
      - name: Enforce REL-SCOPE (optional)
        if: ${{ steps.fetch.outputs.is_rel_scope != 'true' }}
        run: |
          echo "Issue type is not REL-SCOPE; failing as per policy." >&2
          exit 1